11.2.1
False.
A subclass is an extension of a superclass and normally contains more details information than its superclass.

11.2.2
extends

11.2.3
Single inheritance is where a subclass can extend only one parent class.
Multiple inheritance is where a subclass can extends multiple super classes.
Java doesn't support multiple inheritance.

11.3.1
a) "A's no-arg constructor is invoked"
b) compile error because there is no no-argu constructor defined for A

11.3.2
via the super keyword

11.3.3
no - it may also invoke a constructor with arguments

11.4.1 false
11.4.2 false
11.4.3 use the super keyword
11.4.4 use the super keyword

11.5.1
in circle constructor - need to use keyword this. to set the radius.
when invoking the constructor in b - need to invoke the superclass consturctor with super(). need to also use the kwyrod this to set the length.
when invovking the super getArea method - need to use super.getArea()

11.5.2
method overriding - when a subclass has a method with same name and signature as a parent class's method, but different implementation
method overloading - when a method has the same name as a different method, but different signature.

11.5.3
method overriding

11.5.4
It will be a problem if the return type is not a compatible return type.

11.5.5
this method is overloaded

11.5.6
helps avoid errors and easily identified an overloaded class

11.7.1
3 pillars of OOP - inhertiance, polymorphism, encapsulation
Polymorphism - a subclass can be used when its super class is used/ invoked.

11.8.1
A method may be implemented in several classes along the inheritance chain. The JVM decides which method is invoked at runtime. This is known as dynamic binding.

11.8.2
method matching = matching a method based on the declared type of the reference variables
The compiler finds a matching method according to the parameter type, number of parameters,
and order of the parameters at compile time.
method binding - the JVM will bind the implementation of the method at runtime based on the actual type of the variable.

11.8.3
no, because int is of a primitive type and not an object.

11.8.4
- can't pass int[] into the printArray function becaue its a primitive type, so therefore not a subclass of object.

11.8.5
a)
Person
Student

b)
Person
Person (because getInfo on student is a private method)


11.8.6
yes - b's constructor is invoked

11.8.7
i from A is 40
i from A is 60
i from B is 60

11.9.1
a) true
b) false

11.9.2
a) true, true, true, false
b) ture
c) true

11.9.3
a) true
b) false
c) true
d) true
e) false
f) true
g) true
h) false
i) Fruit can only invoke that method if its explicity cas to the apple class. Orange cannot invoke this method
j) orange can invoke the method, fruit can only invoke if its cast to the orange class
k) no
l) no
m) true

11.9.4
Object apple = (Apple)fruit; --> will cause a runtime error

11.10.1
yes - they come from the Object class. The subclasses usually override these methods to provide specific information for these methods.

11.11.1
a) ArrayList<Double> doubles = new ArrayList<>();
b) doubles.add(6.0)
c) doubles.set(0, 6.0)
d) doubles.size()
e) doubles.remove(6.0)
f) double.remove(doubles.size() -1)
g) doubles.contains(6.0)
h) doubles.get(0)

11.11.2
1. can't add a date into the list because the list is of type string
2. can't set index 3 as something because that index doesn't exist in the list yet
3. can't get an item at index 3 because there is no index 3.

11.11.3
it would remove the first 'Dallas'.

for (int i = 0; i < list.size(); i++) {
  if (list.remove(element))
    i--;

11.11.4
because it removes the item at index of 1 instead of the object of type 1.
To remove value 3 from the list, use list.remove(Integer.valueOf(3)).

11.11.5 becuase its tryig to add an integer instead of a double value

11.12.1
to be able to use asList --> need to be an array of object and not an array of primitives

11.12.2
to use the Collections.max function - need to use a list and not an array

11.13.1
MyStack stack = new MyStack();
stack.push(11);

11.14.1 default

11.14.2 protected

11.14.3
no modified --> yes
private - no
protected - yes

11.14.4
mo modifier - no
private - no
protected - yes

11.15.1 by using the final modifier
11.15.2
a) true
b) false
c) true
d) true
e) false
f) false






